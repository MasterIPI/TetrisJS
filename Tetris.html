<html>

<head>
    <title>Tetris Game in browser</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        .game-field-wrapper {
            position: absolute;
            display: flex;
            width: 152px;
            height: 302px;
            background-color: #000000;
            justify-content: center;
            align-items: center;
        }

        .game-screen {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #ded7f1;
        }

        .next-shape-wrapper {
            margin-top: -75px;
            left: calc(50% + 76px + 15px);
            display: flex;
            position: absolute;
            background-color: #000000;
            justify-content: center;
            align-items: center;
            width: 62px;
            height: 62px;
        }

        .next-shape {
            display: flex;
        }

        .score-wrapper,.level-wrapper {
            left: calc(50% + 76px + 15px);
            display: flex;
            position: absolute;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
        }

        .score-wrapper {
            margin-top: -135px;
        }

        .level-wrapper {
            margin-top: -20px;
        }

        .pause {
            visibility: hidden;
        }

        .d-none {
            display: none;
        }

        @media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {
            /* IE10+ CSS */
            .game-field-wrapper {
                position: inherit;
            }

            .next-shape-wrapper {
                margin-top: -105px;
            }

            .score-wrapper {
                margin-top: -155px;
            }

            .level-wrapper {
                margin-top: -40px;
            }
        }

        @supports (-ms-accelerator:true) {
            /* IE Edge 12+ CSS */ 
            .game-field-wrapper {
                position: inherit;
            }

            .next-shape-wrapper {
                margin-top: -155px;
            }

            .score-wrapper {
                margin-top: -265px;
            }

            .level-wrapper {
                margin-top: -40px;
            }
        }

        @supports (-ms-ime-align:auto) {
            /* IE Edge 16+ CSS */ 
            .game-field-wrapper {
                position: inherit;
            }

            .next-shape-wrapper {
                margin-top: -155px;
            }

            .score-wrapper {
                margin-top: -265px;
            }

            .level-wrapper {
                margin-top: -40px;
            }
        }
    </style>
</head>

<body>
    <div class="game-screen">
        <div id="gameFieldWrapper" class="game-field-wrapper">
            <canvas id="gameField" class="game-field"></canvas>
        </div>
        <div id="nextShapeWrapper" class="next-shape-wrapper">
            <canvas id="nextShape" class="next-shape"></canvas>
        </div>
        <div class="score-wrapper">
            <span>Score: <br><label id="scoreCount"></label></span>
        </div>
        <div class="level-wrapper">
            <span>
                Level: <label id="level"></label> <br/>
                <span id="pauseState" class="pause">Paused</span> 
            </span>
        </div>
        <input type="file" id="customTextures" class="d-none" onchange="loadCustomTextures(this)" />
    </div>
    <script>
        class ShapePiece {
            constructor(isSolid, color) {
                this.isSolid = isSolid;
                this.color = color;
            }

            static getTextureSize() {
                return 53;
            }

            static getPieceSize() {
                return 15;
            }

            get innerPieceSize() {
                return 13;
            }

            drawPiece(x, y, context, textures) {
                let pieceSize = ShapePiece.getPieceSize();
                let textureSize = ShapePiece.getTextureSize();

                if (typeof this.color === 'string') {
                    context.fillStyle = this.color;
                    context.fillRect(x * pieceSize + 1, y * pieceSize + 1, this.innerPieceSize, this.innerPieceSize);
                    return;
                }

                context.drawImage(textures, this.color * textureSize, 0, textureSize, textureSize, x * pieceSize, y * pieceSize, pieceSize, pieceSize);
            }
        }

    class Shape {
        constructor(color, solidArray) {
            let shapeSize = Shape.getShapeSize();
            this.shapePieces = new Array(shapeSize * shapeSize);

            if (!color) {
                color = '';
            }

            if (!solidArray) {
                solidArray = [false, false, false, false,
                    false, false, false, false,
                    false, false, false, false,
                    false, false, false, false];
            }

            for (let piece = 0; piece < solidArray.length; piece++) {
                this.shapePieces[piece] = new ShapePiece(solidArray[piece], color);
            }
        }

        static getShapeSize() {
            return 4;
        }

        setColor(color) {
            for (let piece = 0; piece < this.shapePieces.length; piece++) {
                this.shapePieces[piece].color = color;
            }
        }

        drawShape(x, y, context, textures) {
            let shapeSize = Shape.getShapeSize();
            for (let shapeY = 0; shapeY < shapeSize; shapeY++) {
                for (let shapeX = 0; shapeX < shapeSize; shapeX++) {
                    let piece = this.shapePieces[this.getArrayIndexFromXY(shapeX, shapeY)];
                    if (piece.isSolid) {
                        piece.drawPiece(shapeX + x, shapeY + y, context, textures);
                    }
                }
            }
        }

        getArrayIndexFromXY(x, y) {
            return y * Shape.getShapeSize() + x;
        }
    }

    class Game {
        constructor(gameFieldElement, nextShapeFieldElement, scoreCountElement, levelDisplayElement) {
            this.originalTextures = 'data:image/jpeg;base64,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';
            this.originalColors = ['#AAAAAA', '#8BC34A', '#FF5722', '#009688', '#CDDC39', '#3F51B5', '#9C27B0'];
            this.shapeTextures = [0, 1, 2, 3, 4, 5, 6];
            this.shapeColors = this.originalColors;
            this.gameSpeed = 0;
            this.currShapeX = 0;
            this.currShapeY = 0;
            this.clearingLines = false;
            this.gameTimer;
            this.pauseTimer;
            this.isGameOver = true;
            this.isGamePaused = true;
            this.currentScore;
            this.scoreCount = scoreCountElement;
            this.level;
            this.levelDisplay = levelDisplayElement;
            this.scoreToLevelUp;
            this.rotateKeyHold = false;
            this.isUseTextures = false;
            this.textures = new Image();
            this.nextShapeColor = '';
            this.gameFieldPieces = new Array(this.gameFieldWidth * this.gameFieldHeight);
            this.gameField = gameFieldElement;
            let pieceSize = ShapePiece.getPieceSize();
            let shapeSize = Shape.getShapeSize();
            this.gameField.width = pieceSize * this.gameFieldWidth;
            this.gameField.height = pieceSize * this.gameFieldHeight;
            this.gameField.style.backgroundColor = '#000000';
            this.gameFieldContext = this.gameField.getContext('2d');
            this.nextShapeField = nextShapeFieldElement;
            this.nextShapeField.width = pieceSize * shapeSize;
            this.nextShapeField.height = this.nextShapeField.width;
            this.nextShapeField.style.backgroundColor = '#000000';
            this.nextShapeFieldContext = this.nextShapeField.getContext('2d');
            this.currShapeType = 0;
            this.currShapeColor = '';
            this.nextShapeType;
            this.currentShape = new Shape();
            this.nextShape;
            this.shapes = new Array(
                new Shape('', [
                    false, true, true, false,
                    true, true, false, false,
                    false, false, false, false,
                    false, false, false, false
                ]),
                new Shape('', [
                    true, true, false, false,
                    false, true, true, false,
                    false, false, false, false,
                    false, false, false, false
                ]),
                new Shape('', [
                    false, true, false, false,
                    false, true, false, false,
                    false, true, true, false,
                    false, false, false, false
                ]),
                new Shape('', [
                    false, false, true, false,
                    false, false, true, false,
                    false, true, true, false,
                    false, false, false, false
                ]),
                new Shape('', [
                    true, true, false, false,
                    true, true, false, false,
                    false, false, false, false,
                    false, false, false, false
                ]),
                new Shape('', [
                    true, true, true, false,
                    false, true, false, false,
                    false, false, false, false,
                    false, false, false, false
                ]),
                new Shape('', [
                    false, false, true, false,
                    false, false, true, false,
                    false, false, true, false,
                    false, false, true, false
                ])
            );
        }

        get upArrow() {
            return 38;
        }

        get rightArrow() {
            return 39;
        }

        get leftArrow() {
            return 37;
        }

        get downArrow() {
            return 40;
        }

        get enterKey() {
            return 13;
        }

        get changeRenderModeKey() {
            return 84; //t
        }

        get loadCustomTexturesKey() {
            return 80; //p
        }

        get gameFieldWidth() {
            return 10;
        }

        get gameFieldHeight() {
            return 20;
        }

        get scoreToLevelUpStep() {
            return 5000;
        }

        get startShapeX() {
            return 4;
        }

        get startShapeY() {
            return -2;
        }

        clearGameField() {
            this.gameFieldContext.clearRect(0, 0, this.gameField.width, this.gameField.height);
        }

        clearNextShapeField() {
            this.nextShapeFieldContext.clearRect(0, 0, this.nextShapeField.width, this.nextShapeField.height);
        }

        drawGameField() {
            this.clearGameField();

            if (this.isUseTextures) {
                this.clearNextShapeField();
                this.nextShape.drawShape(0, 0, this.nextShapeFieldContext, this.textures);
            }

            if (!this.isUseTextures) {
                this.clearNextShapeField();
                this.nextShape.drawShape(0, 0, this.nextShapeFieldContext, this.textures);
            }

            for (let fieldY = 0; fieldY < this.gameFieldHeight; fieldY++) {
                for (let fieldX = 0; fieldX < this.gameFieldWidth; fieldX++) {
                    let currentGameFieldPiece = this.gameFieldPieces[this.getArrayIndexFromXY(fieldX, fieldY)];
                    if (currentGameFieldPiece.isSolid) {
                        currentGameFieldPiece.drawPiece(fieldX, fieldY, this.gameFieldContext, this.textures);
                    }
                }
            }

            if (this.currShape) {
                this.currShape.drawShape(this.currShapeX, this.currShapeY, this.gameFieldContext, this.textures);
            }
        }

        getNextShapeType() {
            return Math.floor(Math.random() * this.shapes.length);
        }

        changeRenderMode(forceTextures) {
            this.isUseTextures = !this.isUseTextures;
            if (forceTextures) {
                this.isUseTextures = forceTextures;
            }

            if (this.isUseTextures || forceTextures) {
                this.shapeColors = this.shapeTextures;
                if (typeof this.currShapeColor === 'string' && typeof this.nextShapeColor === 'string') {
                    this.currShapeColor = this.shapeColors[this.originalColors.findIndex((elem) => { return this.currShapeColor == elem; })];
                    this.nextShapeColor = this.shapeColors[this.originalColors.findIndex((elem) => { return this.nextShapeColor == elem; })];
                }
            }

            if (!this.isUseTextures) {
                this.shapeColors = this.originalColors;
                this.currShapeColor = this.shapeColors[this.currShapeColor];
                this.nextShapeColor = this.shapeColors[this.nextShapeColor];
            }

            this.drawGameField();
        }

        getShapeHexColor(shapeType) {
            return this.shapeColors[shapeType];
        }

        getShape(shapeType) {
            return this.shapes[shapeType];
        }

        getArrayIndexFromXY(x, y) {
            return y * this.gameFieldWidth + x;
        }

        initializeNewShape() {
            this.currShapeType = this.nextShapeType ? this.nextShapeType : this.getNextShapeType();
            this.currShapeX = this.currShapeType == 6 ? this.startShapeX - 2 : this.startShapeX;
            this.currShapeY = this.startShapeY;
            this.nextShapeType = this.getNextShapeType();
            this.currShape = this.nextShape ? this.nextShape : this.initialShapeRotation(this.currShapeX, this.currShapeY, this.getShape(this.currShapeType), this.currShapeType);
            this.nextShape = this.initialShapeRotation(this.currShapeX, this.currShapeY, this.getShape(this.nextShapeType), this.nextShapeType);
            this.clearNextShapeField();
            this.nextShapeColor = this.getShapeHexColor(this.nextShapeType);
            this.nextShape.setColor(this.nextShapeColor);
            this.nextShape.drawShape(0, 0, this.nextShapeFieldContext, this.textures);
            this.currShapeColor = this.getShapeHexColor(this.currShapeType);
            this.currShape.setColor(this.currShapeColor);
            this.clearingLines = false;
        }

        initializeGameField() {
            //let onLoadTextures = (event) => {
            //    event.target.width = this.naturalWidth;
            //    this.height = this.naturalHeight;
            //    if (this.src !== this.originalTextures && !this.isUseTextures || this.src === this.originalTextures && this.isUseTextures || this.src !== this.originalTextures && this.isUseTextures) {
            //        this.changeRenderMode(true);
            //    }
            //};

            //this.textures.onload = onLoadTextures;

            this.textures.src = this.originalTextures;

            if (this.isUseTextures) {
                this.shapeColors = this.shapeTextures;
            }

            if (!this.isUseTextures) {
                this.shapeColors = this.originalColors;
            }

            for (let piece = 0; piece < this.gameFieldPieces.length; piece++) {
                this.gameFieldPieces[piece] = new ShapePiece(false, '');
            }

            this.currentScore = 0;
            this.level = 0;
            this.levelDisplay.innerText = this.level;
            this.scoreCount.innerText = this.currentScore;
            this.gameSpeed = 1300;
            this.scoreToLevelUp = this.scoreToLevelUpStep;
            this.rotateKeyHold = false;

            this.initializeNewShape();
        }

        start() {
            this.isGamePaused = false;
            this.isGameOver = false;
            window.onkeydown = this.gameControls;
            window.onkeyup = this.rotationUnlock;
            this.initializeGameField();
            this.gameFunction(this);
            this.gameTimer = setInterval(this.gameFunction, this.gameSpeed, this);
        }

        gameOver() {
            this.isGamePaused = true;
            this.isGameOver = true;
            clearInterval(this.gameTimer);
            window.onkeydown = this.gameOverControls;
            this.clearGameField();
            this.clearNextShapeField();
        }

        gameFunction(game) {
            game.moveDownAndCheckForGameOver();

            if (!game.isGameOver) {
                game.drawGameField();
            }
        }

        sleep(milliseconds) {
            var start = new Date().getTime();
            for (var i = 0; i < 1e7; i++) {
                if ((new Date().getTime() - start) > milliseconds) {
                    break;
                }
            }
        }

        pauseUnpauseGame() {
            if (!this.isGamePaused) {
                clearInterval(this.gameTimer);
                this.showPauseState();
            }

            if (this.isGamePaused) {
                this.gameTimer = setInterval(this.gameFunction, this.gameSpeed, this);
                this.hidePauseState();
            }

            this.isGamePaused = !this.isGamePaused;
        }

        moveShapeLeft() {
            if (!this.checkCollision(this.currShapeX - 1, this.currShapeY, this.currShape)) {
                this.currShapeX -= 1;
            }
        }

        moveShapeRight() {
            if (!this.checkCollision(this.currShapeX + 1, this.currShapeY, this.currShape)) {
                this.currShapeX += 1;
            }
        }

        moveShapeDown() {
            if (!this.checkCollision(this.currShapeX, this.currShapeY + 1, this.currShape)) {
                this.currShapeY += 1;
                return true;
            }

            return false;
        }

        checkLines() {
            let lineIndexes = [];
            let isLine = false;

            for (let fieldY = 0; fieldY < 4; fieldY++) {
                if (this.currShapeY + this.fieldY < this.gameFieldHeight) {
                    for (let fieldX = 0; fieldX < this.gameFieldWidth; fieldX++) {
                        if (!this.gameFieldPieces[this.getArrayIndexFromXY(fieldX, this.currShapeY + fieldY, this.gameFieldWidth)].isSolid) {
                            isLine = false;
                            break;
                        }

                        isLine = true;
                    }

                    if (isLine) {
                        lineIndexes.push(this.currShapeY + fieldY);
                    }
                }
            }

            return lineIndexes;
        }

        removeLines(lineIndexes) {
            let scoreLineMultiplier = 0;

            if (lineIndexes.length > 0) {
                for (let line = 0; line < lineIndexes.length; line++) {
                    for (let fieldX = 0; fieldX < this.gameFieldWidth; fieldX++) {
                        this.gameFieldPieces[this.getArrayIndexFromXY(fieldX, lineIndexes[line])].isSolid = false;
                    }

                    for (fieldY = lineIndexes[line]; fieldY >= 0; fieldY--) {
                        for (fieldX = 0; fieldX < this.gameFieldWidth; fieldX++) {
                            gameFieldPieces[this.getArrayIndexFromXY(fieldX, fieldY)].isSolid = fieldY == 0 ? false : this.gameFieldPieces[this.getArrayIndexFromXY(fieldX, fieldY - 1, this.gameFieldWidth)];
                        }
                    }

                    this.drawGameField();
                }

                scoreLineMultiplier = lineIndexes.length;

                if (lineIndexes.length == 3) {
                    scoreLineMultiplier = 4;
                }

                if (lineIndexes.length == 4) {
                    scoreLineMultiplier = 10;
                }

                this.currentScore += 100 * scoreLineMultiplier;
                this.scoreCount.innerText = this.currentScore;

                if (this.currentScore >= this.scoreToLevelUp && this.gameSpeed > 100) {
                    this.scoreToLevelUp += this.scoreToLevelUpStep;
                    this.gameSpeed -= 100;

                    this.level += 1;
                    this.levelDisplay.innerText = this.level;

                    clearInterval(this.gameTimer);
                    this.gameTimer = setInterval(this.gameFunction, this.gameSpeed, this);
                }
            }

            return true;
        }

        rotateShape(shapeX, shapeY, shape, shapeType) {
            if (shapeType == 4) {
                return shape;
            }

            let shapeSize = Shape.getShapeSize();

            let tmpShape = new Shape('', [
                false, false, false, false,
                false, false, false, false,
                false, false, false, false,
                false, false, false, false
            ]);

            if (shapeType == 5) {
                for (let tmpShapeY = 0; tmpShapeY < shapeSize - 1; tmpShapeY++) {
                    for (let tmpShapeX = 0; tmpShapeX < shapeSize - 1; tmpShapeX++) {
                        tmpShape.shapePieces[tmpShape.getArrayIndexFromXY(tmpShapeX, tmpShapeY)] = shape.shapePieces[shape.getArrayIndexFromXY(tmpShapeY, shapeSize - 2 - tmpShapeX)]
                    }
                }
            }

            if (shapeType == 1 || shapeType == 0) {
                if (shapeType == 0 && shape.shapePieces[1].isSolid || shapeType == 1 && shape.shapePieces[0].isSolid) {
                    for (let tmpShapeY = 0; tmpShapeY < shapeSize - 1; tmpShapeY++) {
                        for (let tmpShapeX = 0; tmpShapeX < shapeSize - 1; tmpShapeX++) {
                            let shapeIndex = shape.getArrayIndexFromXY(tmpShapeY, shapeSize - 3 - tmpShapeX);
                            if (shapeIndex < 0 || shapeIndex > shape.shapePieces.length) {
                                tmpShape.shapePieces[tmpShape.getArrayIndexFromXY(tmpShapeX, tmpShapeY)].color = shape.shapePieces[0].color;
                                continue;
                            }
                            tmpShape.shapePieces[tmpShape.getArrayIndexFromXY(tmpShapeX, tmpShapeY)] = shape.shapePieces[shapeIndex];
                        }
                    }
                }

                if (shapeType == 0 && !shape.shapePieces[1].isSolid) {
                    tmpShape = this.getShape(shapeType);
                }

                if (shapeType == 1 && !shape.shapePieces[0].isSolid) {
                    tmpShape = this.getShape(shapeType);
                }
            }

            if (shapeType == 6) {
                if (shape.shapePieces[6].isSolid) {
                    for (let tmpShapeX = 0; tmpShapeX < shapeSize; tmpShapeX++) {
                        tmpShape.shapePieces[tmpShapeX].isSolid = true;
                        tmpShape.shapePieces[tmpShapeX].color = shape.shapePieces[6].color;
                    }
                }

                if (!shape.shapePieces[6].isSolid) {
                    for (let tmpShapeY = 0; tmpShapeY < shapeSize; tmpShapeY++) {
                        tmpShape.shapePieces[tmpShape.getArrayIndexFromXY(2, tmpShapeY)].isSolid = true;
                        tmpShape.shapePieces[tmpShape.getArrayIndexFromXY(2, tmpShapeY)].color = shape.shapePieces[6].color;
                    }
                }
            }

            if (shapeType == 2 || shapeType == 3) {
                for (let tmpShapeY = 0; tmpShapeY < shapeSize; tmpShapeY++) {
                    for (let tmpShapeX = 0; tmpShapeX < shapeSize; tmpShapeX++) {
                        tmpShape.shapePieces[tmpShape.getArrayIndexFromXY(tmpShapeX, tmpShapeY)] = shape.shapePieces[shape.getArrayIndexFromXY(tmpShapeY, shapeSize - 1 - tmpShapeX)]
                    }
                }
            }

            let collided = this.checkCollision(shapeX, shapeY, tmpShape);

            if (!collided) {
                shape = tmpShape;
                return shape;
            }

            if (collided && shapeType != 4 && shapeType != 6) {
                if (shapeX < this.gameFieldWidth / 2) {
                    shapeX += 1;

                    if (!this.checkCollision(shapeX, shapeY, tmpShape)) {
                        shape = tmpShape;
                        this.currShapeX = shapeX;
                        return shape;
                    }
                }

                if (shapeX > this.gameFieldWidth / 2) {
                    shapeX -= 1;

                    if (!this.checkCollision(shapeX, shapeY, tmpShape)) {
                        shape = tmpShape;
                        this.currShapeX = shapeX;
                        return shape;
                    }
                }
            }

            return shape;
        }

        checkCollision(x, y, shape) {
            let shapeSize = Shape.getShapeSize();
            for (let shapeY = 0; shapeY < shapeSize; shapeY++) {
                for (let shapeX = 0; shapeX < shapeSize; shapeX++) {
                    if (shape.shapePieces[shape.getArrayIndexFromXY(shapeX, shapeY)].isSolid) {
                        let isInBounds = (shapeX + x < this.gameFieldWidth) && (shapeX + x >= 0) && (shapeY + y < this.gameFieldHeight);
                        let piece = this.gameFieldPieces[this.getArrayIndexFromXY(shapeX + x, shapeY + y)];

                        if (isInBounds && !piece) {
                            continue;
                        }

                        if (!isInBounds || piece.isSolid) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        translateShapeIntoField(x, y, shape) {
            let shapeSize = Shape.getShapeSize();
            for (let shapeY = 0; shapeY < shapeSize; shapeY++) {
                for (let shapeX = 0; shapeX < shapeSize; shapeX++) {
                    if (shapeX + x < this.gameFieldWidth && shapeX + x >= 0 && shapeY + y < this.gameFieldHeight) {
                        let pieceState = this.currShape.shapePieces[this.currShape.getArrayIndexFromXY(shapeX, shapeY)];

                        if (pieceState.isSolid) {
                            this.gameFieldPieces[this.getArrayIndexFromXY(shapeX + x, shapeY + y)] = pieceState;
                        }
                    }
                }
            }

            this.currShape = null;
        }

        showPauseState() {
            if (this.pauseTimer) {
                clearTimeout(this.pauseTimer);
                this.pauseTimer = null;
            }

            let pauseElement = document.getElementById("pauseState");

            let hidden = pauseElement.classList.contains("pause");

            if (hidden) {
                pauseElement.classList.remove("pause");
            }

            if (!hidden) {
                pauseElement.classList.add("pause");
            }

            this.pauseTimer = setTimeout(this.showPauseState, 500);
        }

        initialShapeRotation(x, y, shape, shapeType) {
            if (shapeType == 4) {
                return shape;
            }

            let rotationCountMax = 3;

            let rotationCount = Math.floor(Math.random() * rotationCountMax);

            for (let rotation = 0; rotation < rotationCount; rotation++) {
                shape = this.rotateShape(x, y, shape, shapeType);
            }

            return shape;
        }

        hidePauseState() {
            clearInterval(this.pauseTimer);
            let pauseElement = document.getElementById("pauseState");

            if (!pauseElement.classList.contains("pause")) {
                document.getElementById("pauseState").classList.add("pause");
            }
        }

        moveDownAndCheckForGameOver() {
            if (!this.moveShapeDown()) {
                if (this.currShapeY <= 0 && this.checkCollision(this.currShapeX, this.currShapeY + 1, this.currShape)) {
                    this.gameOver();
                }

                if (this.currShapeY > 0) {
                    this.clearingLines = true;
                    this.translateShapeIntoField(this.currShapeX, this.currShapeY, this.currShape);

                    if (this.removeLines(this.checkLines())) {
                        this.initializeNewShape();
                    }
                }
            }
        }

        gameControls(event) {
            if (!this.clearingLines && (event.keyCode == this.leftArrow || event.keyCode == this.rightArrow || event.keyCode == this.downArrow || event.keyCode == this.upArrow) && !this.isGamePaused) {
                if (event.keyCode == this.leftArrow) {
                    this.moveShapeLeft();
                }

                if (event.keyCode == this.rightArrow) {
                    this.moveShapeRight();
                }

                if (event.keyCode == this.downArrow) {
                    this.moveDownAndCheckForGameOver();
                }

                if (event.keyCode == this.upArrow && !this.rotateKeyHold) {
                    this.rotateKeyHold = true;
                    this.currShape = this.rotateShape(this.currShapeX, this.currShapeY, this.currShape, this.currShapeType);
                }

                if (!this.isGameOver) {
                    this.drawGameField();
                }
            }

            if (event.keyCode == this.enterKey) {
                this.pauseUnpauseGame();
            }

            if (event.keyCode == this.loadCustomTexturesKey) {
                if (!this.isGamePaused) {
                    clearInterval(gameTimer);
                    this.showPauseState();
                    this.isGamePaused = true;
                }

                if (this.textures.src === this.originalTextures) {
                    let inputWithNewTextures = document.getElementById("customTextures");
                    inputWithNewTextures.click();
                }

                if (this.textures.src !== this.originalTextures) {
                    this.textures.src = this.originalTextures;
                }
            }

            if (event.keyCode == this.changeRenderModeKey) {
                this.changeRenderMode();
            }
        }

        rotationUnlock(event) {
            if (event.keyCode == this.upArrow) {
                rotateKeyHold = false;
            }
        }

        gameOverControls(event) {
            if (event.keyCode == this.enterKey) {
                this.start();
            }
        }

        loadCustomTextures(input) {
            let fileToLoad = input.files[0];
            let fileReader = new FileReader();

            fileReader.onload = function (fileLoadedEvent) {
                this.textures.src = fileLoadedEvent.target.result;
                input.value = '';
            }
            fileReader.readAsDataURL(fileToLoad);
        }
    }


        window.onload = function () {
            let gameField = document.getElementById("gameField");
            let nextShapeField = document.getElementById("nextShape");
            let scoreCount = document.getElementById("scoreCount");
            let levelDisplay = document.getElementById("level");
            let game = new Game(gameField, nextShapeField, scoreCount, levelDisplay);
            game.start();
        }
    </script>
</body>

</html>